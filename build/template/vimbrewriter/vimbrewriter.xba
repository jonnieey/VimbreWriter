<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="vimbrewriter" script:language="StarBasic">
&apos; vibreoffice - Vi Mode for LibreOffice/OpenOffice
&apos;
&apos; The MIT License (MIT)
&apos;
&apos; Copyright (c) 2014 Sean Yeh
&apos;
&apos; Permission is hereby granted, free of charge, to any person obtaining a copy
&apos; of this software and associated documentation files (the &quot;Software&quot;), to deal
&apos; in the Software without restriction, including without limitation the rights
&apos; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
&apos; copies of the Software, and to permit persons to whom the Software is
&apos; furnished to do so, subject to the following conditions:
&apos;
&apos; The above copyright notice and this permission notice shall be included in
&apos; all copies or substantial portions of the Software.
&apos;
&apos; THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
&apos; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
&apos; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
&apos; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
&apos; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
&apos; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
&apos; THE SOFTWARE.

Option Explicit

&apos; --------
&apos; Globals
&apos; --------
global VIBREOFFICE_STARTED as boolean &apos; Defaults to False
global VIBREOFFICE_ENABLED as boolean &apos; Defaults to False

global oXKeyHandler as object

&apos; Global State
global MODE as String
global VIEW_CURSOR as object
global MULTIPLIER as integer

&apos; --- Added for VISUAL_LINE mode ---
global VISUAL_BASE as object &apos; Position of first selected line in VISUAL_LINE
&apos; ----------------------------------
global LAST_PAGE as integer
global oSelectionListener as object

&apos; -----------
&apos; Singletons
&apos; -----------


Function getCursor
    getCursor = VIEW_CURSOR
End Function

Function getTextCursor
    Dim oTextCursor
     On Error Goto ErrorHandler
    oTextCursor = getCursor().getText.createTextCursorByRange(getCursor())

    getTextCursor = oTextCursor
    Exit Function

    ErrorHandler:
    &apos; Text Cursor does not work in some instances, such as in Annotations
    getTextCursor = Nothing
End Function

&apos; -----------------
&apos; Helper Functions
&apos; -----------------
Sub restoreStatus &apos;restore original statusbar
    Dim oLayout
    oLayout = thisComponent.getCurrentController.getFrame.LayoutManager
    oLayout.destroyElement(&quot;private:resource/statusbar/statusbar&quot;)
    oLayout.createElement(&quot;private:resource/statusbar/statusbar&quot;)
End Sub

Sub setRawStatus(rawText)
    thisComponent.Currentcontroller.StatusIndicator.Start(rawText, 0)
End Sub

Function PadRight(text As String, length As Integer) As String
    Dim s As String
    s = text
    Do While Len(s) &lt; length
        s = s &amp; &quot; &quot;
    Loop
    If Len(s) &gt; length Then
        s = Left(s, length)
    End If
    PadRight = s
End Function

Sub SelectionChange_selectionChanged(oEvent)
     On Error Goto ErrorHandler
    If Not VIBREOFFICE_ENABLED Then Exit Sub
    Dim currentPage As Integer
    currentPage = getPageNum()
    If currentPage &lt;&gt; LAST_PAGE Then
        LAST_PAGE = currentPage
        setStatus(getMultiplier())
    End If
    Exit Sub
    ErrorHandler:
    &apos; Ignore
End Sub

Sub SelectionChange_disposing(oEvent)
    &apos; Required by XEventListener interface; do nothing.
End Sub

Sub setStatus(statusText)
    Dim nTotalPages As Long
    Dim nCurrentPage As Integer
    Dim sFinalStatus As String

    nCurrentPage = getCursor().getPage()
    nTotalPages = thisComponent.CurrentController.PageCount

    Dim sMode As String : sMode = PadRight(MODE, 12)
    Dim sStatusText As String : sStatusText = PadRight(statusText, 5)
    Dim sSpec As String : sSpec = PadRight(&quot;special: &quot; &amp; getSpecial(), 11)
    Dim sMod As String : sMod = PadRight(&quot;modifier: &quot; &amp; getMovementModifier(), 12)
    Dim sPage As String : sPage = PadRight(&quot;page: &quot; &amp; nCurrentPage &amp; &quot;/&quot; &amp; nTotalPages, 14)
    Dim sParagraphs As String : sParagraphs = PadRight(&quot;paragraphs: &quot; &amp; getParagraphCount(), 17)
    Dim sWords As String : sWords = PadRight(&quot;Words: &quot; &amp; getWordCount(), 13)
    Dim sFileName As String : sFileName = &quot;File: &quot; &amp; getCurrentFileName()

    sFinalStatus = sMode &amp; &quot; | &quot; &amp; sStatusText &amp; &quot; | &quot; &amp; sSpec &amp; &quot;  | &quot; &amp; sMod &amp; &quot; | &quot; &amp; sPage &amp; &quot; | &quot; &amp; sParagraphs &amp; &quot; | &quot; &amp; sWords &amp; &quot; | &quot; &amp; sFileName

    setRawStatus(sFinalStatus)
End Sub

Sub setMode(modeName)
    MODE = modeName
    setRawStatus(modeName)
End Sub

&apos; --- Added: formatVisualBase for VISUAL_LINE mode ---
Function formatVisualBase()
    Dim oTextCursor
    oTextCursor = getTextCursor()
    VISUAL_BASE = getCursor().getPosition()

    &apos; Select the current line by moving cursor to start of the line below and
    &apos; then back to the start of the current line.
    getCursor().gotoEndOfLine(False)
    If getCursor().getPosition().Y() = VISUAL_BASE.Y() Then
        getCursor().goRight(1, False)
    End If
    getCursor().goLeft(1, True)
    getCursor().gotoStartOfLine(True)
End Function
&apos; ----------------------------------------------------
Function MoveWordBackward(oTC As Object, bExpand As Boolean) As Boolean
    &apos; Moves the text cursor oTC backward to the start of the previous word.
    &apos; Returns True if movement occurred, False if at document start.
     On Error Goto ErrorHandler

    Dim dc_db As Boolean
    dc_db = False
    Dim bMoved As Boolean
    bMoved = False

    &apos; Special handling for start of paragraph
    If oTC.isStartOfParagraph() Then
        If oTC.goLeft(1, bExpand) Then
            bMoved = True
            If getSpecial() = &quot;c&quot; Or getSpecial() = &quot;d&quot; Then
                dc_db = True
                oTC.collapseToStart()
            End If
        Else
            &apos; At document start
            MoveWordBackward = False
            Exit Function
        End If
    Else
        &apos; If we are at start of a word, move left once to get out of it
        If oTC.isStartOfWord() Then
            If Not oTC.goLeft(1, bExpand) Then
                MoveWordBackward = False
                Exit Function
            End If
            bMoved = True
        End If
    End If

    &apos; Move left until start of word or empty line
    Do While Not (oTC.isStartOfWord() Or (oTC.isStartOfParagraph() And oTC.isEndOfParagraph()))
        If Not oTC.goLeft(1, bExpand) Then
            Exit Do
        End If
        bMoved = True
    Loop

    If Not bMoved Then
        MoveWordBackward = False
        Exit Function
    End If

    &apos; Handle special case for delete/change commands
    If dc_db Then
        Dim oTC2 As Object
        Set oTC2 = getCursor().getText.createTextCursorByRange(oTC)
        Do While Not (oTC2.isEndOfWord() Or oTC2.isStartOfParagraph())
            If Not oTC2.goLeft(1, bExpand) Then Exit Do
        Loop
        If oTC2.isStartOfParagraph() Then
            Set oTC = oTC2
            oTC.gotoRange(oTC.getStart(), bExpand)
            If getSpecial() = &quot;d&quot; Then
                oTC.goRight(1, bExpand)
            End If
        End If
    End If

    MoveWordBackward = True
    Exit Function

    ErrorHandler:
    MoveWordBackward = False
End Function

Function gotoMode(sMode)
    Select Case sMode
        Case &quot;NORMAL&quot; :
            setMode(&quot;NORMAL&quot;)
            setMovementModifier(&quot;&quot;)
        Case &quot;INSERT&quot; :
            setMode(&quot;INSERT&quot;)
        Case &quot;VISUAL&quot; :
            setMode(&quot;VISUAL&quot;)
            Dim oTextCursor
            oTextCursor = getTextCursor()
            oTextCursor.gotoRange(oTextCursor.getStart(), False)
            thisComponent.getCurrentController.Select(oTextCursor)
        Case &quot;VISUAL_LINE&quot; :
            setMode(&quot;VISUAL_LINE&quot;)
            formatVisualBase()
    End Select
End Function

Sub cursorReset(oTextCursor)
    oTextCursor.gotoRange(oTextCursor.getStart(), False)
    oTextCursor.goRight(1, False)
    oTextCursor.goLeft(1, True)
    thisComponent.getCurrentController.Select(oTextCursor)
End Sub

Function samePos(oPos1, oPos2)
    samePos = oPos1.X() = oPos2.X() And oPos1.Y() = oPos2.Y()
End Function

Function genString(sChar, iLen)
    Dim sResult, i
    sResult = &quot;&quot;
    For i = 1 To iLen
        sResult = sResult &amp; sChar
    Next i
    genString = sResult
End Function

&apos; Yanks selection to system clipboard.
&apos; If bDelete is true, will delete selection.
Sub yankSelection(bDelete)
    Dim dispatcher As Object
    dispatcher = createUnoService(&quot;com.sun.star.frame.DispatchHelper&quot;)
    dispatcher.executeDispatch(ThisComponent.CurrentController.Frame, &quot;.uno:Copy&quot;, &quot;&quot;, 0, Array())

    If bDelete Then
        getTextCursor().setString(&quot;&quot;)
    End If
End Sub


Sub pasteSelection()
    Dim oTextCursor, dispatcher As Object

    &apos; Deselect if in NORMAL mode to avoid overwriting the character underneath
    &apos; the cursor
    If MODE = &quot;NORMAL&quot; Then
        oTextCursor = getTextCursor()
        oTextCursor.gotoRange(oTextCursor.getStart(), False)
        thisComponent.getCurrentController.Select(oTextCursor)
    End If

    dispatcher = createUnoService(&quot;com.sun.star.frame.DispatchHelper&quot;)
    dispatcher.executeDispatch(ThisComponent.CurrentController.Frame, &quot;.uno:Paste&quot;, &quot;&quot;, 0, Array())
End Sub


&apos; -----------------------------------
&apos; Special Mode (for chained commands)
&apos; -----------------------------------
global SPECIAL_MODE As String
global SPECIAL_COUNT As integer

Sub setSpecial(specialName)
    SPECIAL_MODE = specialName

    If specialName = &quot;&quot; Then
        SPECIAL_COUNT = 0
    Else
        SPECIAL_COUNT = 2
    End If
End Sub

Function getSpecial()
    getSpecial = SPECIAL_MODE
End Function

Function getPageNum()
    getPageNum = getCursor().getPage()
End Function

Function getPageCount()
    getPageCount = thisComponent.CurrentController.PageCount
End Function

Function getWordCount()
    getWordCount = thisComponent.WordCount
End Function

Function getParagraphCount()
    getParagraphCount = thisComponent.ParagraphCount
End Function

Function getCurrentFileName()
    getCurrentFileName = thisComponent.getTitle()
End Function

Sub delaySpecialReset()
    SPECIAL_COUNT = SPECIAL_COUNT + 1
End Sub

Sub resetSpecial(Optional bForce)
    If IsMissing(bForce) Then bForce = False

    SPECIAL_COUNT = SPECIAL_COUNT - 1
    If SPECIAL_COUNT &lt;= 0 Or bForce Then
        setSpecial(&quot;&quot;)
    End If
End Sub


&apos; -----------------
&apos; Movement Modifier
&apos; -----------------
&apos;f,i,a
global MOVEMENT_MODIFIER As String



Sub setMovementModifier(modifierName)
    MOVEMENT_MODIFIER = modifierName
End Sub

Function getMovementModifier()
    getMovementModifier = MOVEMENT_MODIFIER
End Function


&apos; --------------------
&apos; Multiplier functions
&apos; --------------------
Sub _setMultiplier(n as integer)
        MULTIPLIER = n
End Sub

Sub resetMultiplier()
     _setMultiplier(0)
    End Sub

Sub addToMultiplier(n as integer)
    Dim sMultiplierStr as String
    &apos; Max multiplier: 10000 (stop accepting additions after 1000)
    If MULTIPLIER &lt;= 1000 Then
        sMultiplierStr = CStr(MULTIPLIER) &amp; CStr(n)
         _setMultiplier(CInt(sMultiplierStr))
        End If
End Sub

&apos; Should only be used if you need the raw value
Function getRawMultiplier()
    getRawMultiplier = MULTIPLIER
End Function

&apos; Same as getRawMultiplier, but defaults to 1 if it is unset (0)
Function getMultiplier()
    If MULTIPLIER = 0 Then
        getMultiplier = 1
    Else
        getMultiplier = MULTIPLIER
    End If
End Function


&apos; -------------
&apos; Key Handling
&apos; -------------
Sub sStartXKeyHandler
    sStopXKeyHandler()

    oXKeyHandler = CreateUnoListener(&quot;KeyHandler_&quot;, &quot;com.sun.star.awt.XKeyHandler&quot;)
    thisComponent.CurrentController.AddKeyHandler(oXKeyHandler)
End Sub

Sub sStopXKeyHandler
    thisComponent.CurrentController.removeKeyHandler(oXKeyHandler)
    If Not IsNull(oSelectionListener) Then
        ThisComponent.CurrentController.removeSelectionChangeListener(oSelectionListener)
    End If
End Sub

Sub XKeyHandler_Disposing(oEvent)
End Sub


&apos; --------------------
&apos; Main Key Processing
&apos; --------------------
Function KeyHandler_KeyPressed(oEvent) as boolean
    Dim oTextCursor

    &apos; Exit if plugin is not enabled
    If IsMissing(VIBREOFFICE_ENABLED) Or Not VIBREOFFICE_ENABLED Then
        KeyHandler_KeyPressed = False
        Exit Function
    End If

    &apos; Exit if TextCursor does not work (as in Annotations)
    oTextCursor = getTextCursor()
    If oTextCursor Is Nothing Then
        KeyHandler_KeyPressed = False
        Exit Function
    End If

    Dim bConsumeInput, bIsMultiplier, bIsModified, bIsSpecial
    bConsumeInput = True &apos; Block all inputs by default
    bIsMultiplier = False &apos; reset multiplier by default
    bIsModified = oEvent.Modifiers &gt; 1 &apos; If Ctrl or Alt is held down. (Shift=1)
    bIsSpecial = getSpecial() &lt;&gt; &quot;&quot;


    &apos; --------------------------
    &apos; Process global shortcuts, exit if matched (like ESC)
    If ProcessGlobalKey(oEvent) Then
        &apos; Pass

        &apos; If INSERT mode, allow all inputs
    ElseIf MODE = &quot;INSERT&quot; Then
        bConsumeInput = False

        &apos; If Change Mode
        &apos; ElseIf MODE = &quot;NORMAL&quot; And Not bIsSpecial And getMovementModifier() = &quot;&quot; And ProcessModeKey(oEvent) Then
    ElseIf ProcessModeKey(oEvent) Then
        &apos; Pass

        &apos; Replace Key
    ElseIf getSpecial() = &quot;r&quot; And Not bIsModified Then
        Dim iLen
        iLen = Len(getCursor().getString())
        getCursor().setString(Chr(oEvent.KeyChar))

        &apos; Multiplier Key
    ElseIf ProcessNumberKey(oEvent) Then
        bIsMultiplier = True
        delaySpecialReset()

        &apos; Normal Key
    ElseIf ProcessNormalKey(oEvent.KeyChar, oEvent.Modifiers) Then
        &apos; Pass

        &apos; If is modified but doesn&apos;t match a normal command, allow input
        &apos;   (Useful for built-in shortcuts like Ctrl+s, Ctrl+w)
    ElseIf bIsModified Then
        bConsumeInput = False

        &apos; Movement modifier here?
    ElseIf ProcessMovementModifierKey(oEvent.KeyChar) Then
        delaySpecialReset()

        &apos; If standard movement key (in VISUAL or VISUAL_LINE mode) like arrow keys, home, end
    ElseIf (MODE = &quot;VISUAL&quot; Or MODE = &quot;VISUAL_LINE&quot;) And ProcessStandardMovementKey(oEvent) Then
        &apos; Pass

        &apos; If bIsSpecial but nothing matched, return to normal mode
    ElseIf bIsSpecial Then
        gotoMode(&quot;NORMAL&quot;)

        &apos; Allow non-letter keys if unmatched
    ElseIf oEvent.KeyChar = 0 Then
        bConsumeInput = False
    End If
    &apos; --------------------------

    &apos; Reset Special
    resetSpecial()

    &apos; Reset multiplier if last input was not number and not in special mode
    If Not bIsMultiplier And getSpecial() = &quot;&quot; And getMovementModifier() = &quot;&quot; Then
        resetMultiplier()
    End If
    setStatus(getMultiplier())

    &apos; Update the terminal-style cursor appearance after every keypress.
    &apos; Done here in KeyPressed rather than KeyReleased because KeyReleased
    &apos; must return True (consume the event) to prevent the key firing twice.
    oTextCursor = getTextCursor()
    If Not (oTextCursor Is Nothing) Then
        If MODE = &quot;NORMAL&quot; Then
            cursorReset(oTextCursor)
        ElseIf MODE = &quot;INSERT&quot; Then
            oTextCursor.gotoRange(oTextCursor.getStart(), False)
            thisComponent.getCurrentController.Select(oTextCursor)
        End If
    End If

    KeyHandler_KeyPressed = bConsumeInput
End Function

Function KeyHandler_KeyReleased(oEvent) As boolean
    &apos; Always consume the KeyReleased event in NORMAL and VISUAL mode.
    &apos; Returning False lets the release propagate to LibreOffice, which
    &apos; re-processes it as input — causing every command to fire twice.
    &apos; INSERT mode passes releases through so the application can handle
    &apos; auto-complete, IME, etc. normally.
    KeyHandler_KeyReleased = (MODE &lt;&gt; &quot;INSERT&quot;)
End Function


&apos; ----------------
&apos; Processing Keys
&apos; ----------------
Function ProcessGlobalKey(oEvent)
    Dim bMatched, bIsControl
    bMatched = True
    bIsControl = (oEvent.Modifiers = 2) Or (oEvent.Modifiers = 8)

    &apos; PRESSED ESCAPE (or ctrl+[)
    &apos; KeyCode 1281 = Escape, KeyCode 1315 = &apos;[&apos;, ascii 91
    If oEvent.KeyCode = 1281 Or (oEvent.KeyCode = 1315 And bIsControl) Then
        &apos; Move cursor back if was in INSERT (but stay on same line)
        If MODE &lt;&gt; &quot;NORMAL&quot; And Not getCursor().isAtStartOfLine() Then
            getCursor().goLeft(1, False)
        End If

        resetSpecial(True)
        gotoMode(&quot;NORMAL&quot;)
    Else
        bMatched = False
    End If
    ProcessGlobalKey = bMatched
End Function


Function ProcessStandardMovementKey(oEvent)
    Dim c, bMatched
    c = oEvent.KeyCode

    bMatched = True
    If (MODE &lt;&gt; &quot;VISUAL&quot; And MODE &lt;&gt; &quot;VISUAL_LINE&quot;) Then
        bMatched = False
    Else
        Select Case c
            Case 1024 &apos; Down arrow
                ProcessMovementKey(106, 1, 0, True) &apos; 106=&apos;j&apos;
            Case 1025 &apos; Up arrow
                ProcessMovementKey(107, 1, 0, True) &apos; 107=&apos;k&apos;
            Case 1026 &apos; Left arrow
                ProcessMovementKey(104, 1, 0, True) &apos; 104=&apos;h&apos;
            Case 1027 &apos; Right arrow
                ProcessMovementKey(108, 1, 0, True) &apos; 108=&apos;l&apos;
            Case 1028 &apos; Home
                ProcessMovementKey(94, 1, 0, True) &apos; 94=&apos;^&apos;
            Case 1029 &apos; End
                ProcessMovementKey(36, 1, 0, True) &apos; 36=&apos;$&apos;
            Case Else
                bMatched = False
        End Select
    End If

    ProcessStandardMovementKey = bMatched
End Function


Function ProcessNumberKey(oEvent)
    &apos; If a movement modifier (f/F/t/T) is active, digits are target chars, not multipliers
    If getMovementModifier() &lt;&gt; &quot;&quot; Then
        ProcessNumberKey = False
        Exit Function
    End If

    Dim key as Integer
    key = oEvent.KeyChar

    &apos; 48=&apos;0&apos; through 57=&apos;9&apos;
    If key &gt;= 48 And key &lt;= 57 Then
        Dim digit As Integer
        digit = key - 48
        &apos; If multiplier is 0 and the digit is 0, this is the &apos;0&apos; motion, not a multiplier
        If getRawMultiplier() = 0 And digit = 0 Then
            ProcessNumberKey = False
            Exit Function
        End If
        &apos; Otherwise add to multiplier
        addToMultiplier(digit)
        ProcessNumberKey = True
    Else
        ProcessNumberKey = False
    End If
End Function


Function ProcessModeKey(oEvent)
    Dim bIsModified, key as Integer
    bIsModified = oEvent.Modifiers &gt; 1 &apos; If Ctrl or Alt is held down. (Shift=1)
    &apos; Don&apos;t change modes in these circumstances
    If MODE &lt;&gt; &quot;NORMAL&quot; Or bIsModified Or getSpecial() &lt;&gt; &quot;&quot; Or getMovementModifier() &lt;&gt; &quot;&quot; Then
        ProcessModeKey = False
        Exit Function
    End If

    key = oEvent.KeyChar

    &apos; Mode matching
    Dim bMatched
    bMatched = True
    Select Case key
            &apos; Insert modes
            &apos; 105=&apos;i&apos;, 97=&apos;a&apos;, 73=&apos;I&apos;, 65=&apos;A&apos;, 111=&apos;o&apos;, 79=&apos;O&apos;
        Case 105, 97, 73, 65, 111, 79 : &apos; i,a,I,A,o,O
            If key = 97 Then getCursor().goRight(1, False)
            If key = 73 Then ProcessMovementKey(94, 1, 0)
            If key = 65 Then ProcessMovementKey(36, 1, 0)

            If key = 111 Then &apos; &apos;o&apos;: open line below
                ProcessMovementKey(36, 1, 0) &apos; &apos;$&apos;
                ProcessMovementKey(108, 1, 0) &apos; &apos;l&apos;
                getCursor().setString(Chr(13))
                If Not getCursor().isAtStartOfLine() Then
                    getCursor().setString(Chr(13) &amp; Chr(13))
                    ProcessMovementKey(108, 1, 0)
                End If
            End If

            If key = 79 Then &apos; &apos;O&apos;: open line above
                ProcessMovementKey(94, 1, 0) &apos; &apos;^&apos;
                getCursor().setString(Chr(13))
                If Not getCursor().isAtStartOfLine() Then
                    ProcessMovementKey(104, 1, 0) &apos; &apos;h&apos;
                    getCursor().setString(Chr(13))
                    ProcessMovementKey(108, 1, 0) &apos; &apos;l&apos;
                End If
            End If

            gotoMode(&quot;INSERT&quot;)
        Case 118 : &apos; 118=&apos;v&apos;
            gotoMode(&quot;VISUAL&quot;)

        Case 86 : &apos; 86=&apos;V&apos;
            gotoMode(&quot;VISUAL_LINE&quot;)
        Case Else :
            bMatched = False
    End Select
    ProcessModeKey = bMatched
End Function


Function ProcessNormalKey(keyChar, modifiers)
    Dim i, bMatched, bIsVisual, iMultiplier, iRawMultiplier, bIsControl
    bIsControl = (modifiers = 2) Or (modifiers = 8)

    bIsVisual = (MODE = &quot;VISUAL&quot; Or MODE = &quot;VISUAL_LINE&quot;)

    iMultiplier = getMultiplier()
    iRawMultiplier = getRawMultiplier()

    &apos; ----------------------
    &apos; 1. Check Movement Key
    &apos; ----------------------

    If keyChar = 48 Or keyChar = 94 Then &apos; 48=&apos;0&apos;, 94=&apos;^&apos;
        iMultiplier = 1
        iRawMultiplier = 0 &apos; optional, not strictly needed
    End If

    bMatched = ProcessMovementKey(keyChar, iMultiplier, iRawMultiplier, bIsVisual, modifiers)

    &apos; If Special: d/c + movement
    If bMatched And (getSpecial() = &quot;d&quot; Or getSpecial() = &quot;c&quot; Or getSpecial() = &quot;y&quot;) Then
        yankSelection((getSpecial() &lt;&gt; &quot;y&quot;))
    End If

    &apos; Reset Movement Modifier
    setMovementModifier(&quot;&quot;)

    &apos; Exit already if movement key was matched
    If bMatched Then
        &apos; If Special: d/c : change mode
        If getSpecial() = &quot;d&quot; Or getSpecial() = &quot;y&quot; Then gotoMode(&quot;NORMAL&quot;)
        If getSpecial() = &quot;c&quot; Then gotoMode(&quot;INSERT&quot;)

        ProcessNormalKey = True
        Exit Function
    End If


    &apos; --------------------
    &apos; 2. Undo/Redo
    &apos; --------------------
    &apos; 117=&apos;u&apos;, 114=&apos;r&apos; (Ctrl+r = redo)
    If keyChar = 117 Or (bIsControl And keyChar = 114) Then &apos; u or Ctrl+r
        For i = 1 To iMultiplier
            Undo(keyChar = 117)
        Next i

        ProcessNormalKey = True
        Exit Function
    End If


    &apos; --------------------
    &apos; 3. Paste
    &apos;   Note: in vim, paste will result in cursor being over the last character
    &apos;   of the pasted content. Here, the cursor will be the next character
    &apos;   after that. Fix?
    &apos; --------------------
    &apos; 112=&apos;p&apos;, 80=&apos;P&apos;
    If keyChar = 112 Or keyChar = 80 Then &apos; &apos;p&apos; or &apos;P&apos;
        &apos; Move cursor right if &quot;p&quot; to paste after cursor
        If keyChar = 112 Then
            ProcessMovementKey(108, 1, 0, False) &apos; 108=&apos;l&apos;
        End If

        For i = 1 To iMultiplier
            pasteSelection()
        Next i

        ProcessNormalKey = True
        Exit Function
    End If

    &apos;---------------------------------------------------
    &apos;               Find and Replace
    &apos;--------------==-----------------------------------
    If keyChar = 47 Then
        Dim frameFind as Object
        Dim dispatcherFind as Object

        frameFind = thisComponent.CurrentController.Frame
        dispatcherFind = createUnoService(&quot;com.sun.star.frame.DispatchHelper&quot;)

        &apos; Uses the specific findbar protocol to focus the search bar
        dispatcherFind.executeDispatch(frameFind, &quot;vnd.sun.star.findbar:FocusToFindbar&quot;, &quot;&quot;, 0, Array())

        ProcessNormalKey = True
        Exit Function
    End If

    &apos; 92 is the key code for &apos;\&apos;
    If keyChar = 92 Then &apos; \
        Dim frame as Object
        Dim dispatcher as Object
        frame = thisComponent.CurrentController.Frame
        dispatcher = createUnoService(&quot;com.sun.star.frame.DispatchHelper&quot;)

        &apos; Launches the built-in Find &amp; Replace dialog
        dispatcher.executeDispatch(frame, &quot;.uno:SearchDialog&quot;, &quot;&quot;, 0, Array())

        ProcessNormalKey = True
        Exit Function
    End If

    &apos; --------------------
    &apos; 4. Check Special/Delete Key
    &apos; --------------------

    &apos; There are no special/delete keys with modifier keys, so exit early
    If modifiers &gt; 1 Then
        ProcessNormalKey = False
        Exit Function
    End If

    &apos; Only &apos;x&apos; or Special (dd, cc) can be done more than once
    &apos; 120=&apos;x&apos;
    If keyChar &lt;&gt; 120 And getSpecial() = &quot;&quot; Then &apos; 120=&apos;x&apos;
        iMultiplier = 1
    End If
    For i = 1 To iMultiplier
        Dim bMatchedSpecial

        &apos; Special/Delete Key
        bMatchedSpecial = ProcessSpecialKey(keyChar)

        bMatched = bMatched Or bMatchedSpecial
    Next i


    ProcessNormalKey = bMatched
End Function


&apos; Function for both undo and redo
Sub Undo(bUndo)
     On Error Goto ErrorHandler

    If bUndo Then
        thisComponent.getUndoManager().undo()
    Else
        thisComponent.getUndoManager().redo()
    End If
    Exit Sub

    &apos; Ignore errors from no more undos/redos in stack
    ErrorHandler:
    Resume Next
End Sub


&apos; Get the current column position (character offset from start of line).
&apos; Used by dd/cc to preserve horizontal position after deleting a line.
Function GetCursorColumn() As Integer
    Dim oVC, oText, oSaved, oTest

    oVC = ThisComponent.CurrentController.getViewCursor()
    oText = ThisComponent.Text

    &apos; Save exact current position
    oSaved = oText.createTextCursorByRange(oVC.getStart())

    &apos; Work on a duplicate model cursor
    oTest = oText.createTextCursorByRange(oSaved)

    &apos; Move duplicate to visual line start using a temporary ViewCursor
    Dim oTempVC
    oTempVC = ThisComponent.CurrentController.getViewCursor()
    oTempVC.gotoRange(oSaved.getStart(), False)
    oTempVC.gotoStartOfLine(False)

    &apos; Now select from visual start to original position using model cursor
    oTest.gotoRange(oTempVC, False)
    oTest.gotoRange(oSaved, True)

    GetCursorColumn = Len(oTest.getString())

    &apos; Restore original cursor position explicitly
    oVC.gotoRange(oSaved, False)
End Function


&apos; Move the cursor to a specific column on the current line, or to the
&apos; end of the line if the line is shorter than the requested column.
Sub SetCursorColumn(col As Integer)
    Dim oVC, oTest As Object
    Dim i, maxCol As Integer

    oVC = getCursor()
    If col &lt;= 0 Then
        oVC.gotoStartOfLine(False)
        Exit Sub
    End If

    oVC.gotoStartOfLine(False)
    oVC.gotoEndOfLine(True)

    maxCol = Len(oVC.getString())
    oVC.gotoStartOfLine(False)
    If col &gt; maxCol Then col = maxCol

    &apos; Move right up to desired column
    oVC.goRight(col, False)
End Sub

Function GetLineTextCursor(Optional bIncludeBreak As Boolean) As Object
    &apos; Returns a text cursor that selects the current line.
    &apos; If bIncludeBreak is True (default), includes the paragraph break.
    Dim oVC, oText, oStartCursor, oEndCursor, oSavedPos
    Set oVC = getCursor()
    Set oText = oVC.getText()

    If IsMissing(bIncludeBreak) Then bIncludeBreak = True

    &apos; Save original cursor position
    Set oSavedPos = oVC.getStart()

    &apos; Move to start of line
    oVC.gotoStartOfLine(False)
    Set oStartCursor = oText.createTextCursorByRange(oVC.getStart())

    &apos; Move to end of line
    oVC.gotoEndOfLine(False)
    If bIncludeBreak Then
        &apos; Try to include the newline character (if any)
        oVC.goRight(1, False)
    End If
    Set oEndCursor = oText.createTextCursorByRange(oVC.getStart())

    &apos; Restore original cursor position
    oVC.gotoRange(oSavedPos, False)

    &apos; Create a cursor spanning from start to end
    Dim oLineCursor
    Set oLineCursor = oText.createTextCursorByRange(oStartCursor.getStart())
    oLineCursor.gotoRange(oEndCursor.getStart(), True)

    Set GetLineTextCursor = oLineCursor
End Function

Function ProcessSpecialKey(keyChar)
    Dim oTextCursor, bMatched, bIsSpecial, bIsDelete
    Dim savedCol As Integer
    bMatched = True
    bIsSpecial = getSpecial() &lt;&gt; &quot;&quot;

    Select Case keyChar
        Case 100, 99, 115, 121 &apos; d,c,s,y
            bIsDelete = (keyChar &lt;&gt; 121)

            If bIsSpecial Then
                Dim bIsSpecialCase
                bIsSpecialCase = (keyChar = 100 And getSpecial() = &quot;d&quot;) Or (keyChar = 99 And getSpecial() = &quot;c&quot;)
                If bIsSpecialCase Then
                    savedCol = GetCursorColumn()
                    Dim oLineCursor
                    Set oLineCursor = GetLineTextCursor(True)
                    thisComponent.getCurrentController.Select(oLineCursor)
                    yankSelection(bIsDelete)
                    If bIsDelete Then
                        SetCursorColumn(savedCol)
                    End If
                Else
                    bMatched = False
                End If
                If bIsSpecialCase And keyChar = 99 Then
                    gotoMode(&quot;INSERT&quot;)
                Else
                    gotoMode(&quot;NORMAL&quot;)
                End If
            ElseIf MODE = &quot;VISUAL&quot; Or MODE = &quot;VISUAL_LINE&quot; Then
                oTextCursor = getTextCursor()
                thisComponent.getCurrentController.Select(oTextCursor)
                yankSelection(bIsDelete)
                If keyChar = 99 Or keyChar = 115 Then gotoMode(&quot;INSERT&quot;)
                If keyChar = 100 Or keyChar = 121 Then gotoMode(&quot;NORMAL&quot;)
            ElseIf MODE = &quot;NORMAL&quot; Then
                If keyChar = 115 Then
                    setSpecial(&quot;c&quot;)
                    gotoMode(&quot;VISUAL&quot;)
                    ProcessNormalKey(108, 0) &apos; 108=&apos;l&apos;
                Else
                    setSpecial(Chr(keyChar))
                    gotoMode(&quot;VISUAL&quot;)
                End If
            End If

        Case 114 &apos; r
            setSpecial(&quot;r&quot;)

        Case Else
            If bIsSpecial Then
                bMatched = False
            Else
                Select Case keyChar
                    Case 120 &apos; x
                        oTextCursor = getTextCursor()
                        thisComponent.getCurrentController.Select(oTextCursor)
                        yankSelection(True)
                        cursorReset(oTextCursor)
                        gotoMode(&quot;NORMAL&quot;)

                    Case 68, 67 &apos; D, C
                        If MODE = &quot;VISUAL&quot; Or MODE = &quot;VISUAL_LINE&quot; Then
                            ProcessMovementKey(94, 1, 0, False)
                            ProcessMovementKey(36, 1, 0, True)
                            ProcessMovementKey(108, 1, 0, True)
                        Else
                            oTextCursor = getTextCursor()
                            oTextCursor.gotoRange(oTextCursor.getStart(), False)
                            thisComponent.getCurrentController.Select(oTextCursor)
                            ProcessMovementKey(36, 1, 0, True)
                        End If
                        yankSelection(True)
                        If keyChar = 68 Then
                            gotoMode(&quot;NORMAL&quot;)
                        Else
                            gotoMode(&quot;INSERT&quot;)
                        End If

                    Case 83 &apos; S
                        If MODE = &quot;NORMAL&quot; Then
                            ProcessMovementKey(94, 1, 0, False)
                            ProcessMovementKey(36, 1, 0, True)
                            yankSelection(True)
                            gotoMode(&quot;INSERT&quot;)
                        Else
                            bMatched = False
                        End If

                    Case Else
                        bMatched = False
                End Select
            End If
    End Select

    ProcessSpecialKey = bMatched
End Function


Function ProcessMovementModifierKey(keyChar)
    Dim bMatched

    bMatched = True
    &apos; 102=&apos;f&apos;, 116=&apos;t&apos;, 70=&apos;F&apos;, 84=&apos;T&apos;, 105=&apos;i&apos;, 97=&apos;a&apos;,

    Select Case keyChar
        Case 102 : setMovementModifier(&quot;f&quot;) &apos; &apos;f&apos;
        Case 116 : setMovementModifier(&quot;t&quot;) &apos; &apos;t&apos;
        Case 70 : setMovementModifier(&quot;F&quot;) &apos; &apos;F&apos;
        Case 84 : setMovementModifier(&quot;T&quot;) &apos; &apos;T&apos;
        Case 105 : setMovementModifier(&quot;i&quot;) &apos; &apos;i&apos;
        Case 97 : setMovementModifier(&quot;a&quot;) &apos; &apos;a&apos;

        Case Else :
            bMatched = False
    End Select

    ProcessMovementModifierKey = bMatched
End Function


Function ProcessSearchKey(oTextCursor, searchType, keyChar, bExpand)
    &apos;-----------
    &apos; Searching
    &apos; keyChar here is a string (the literal character to find), not an ascii int.
    &apos; It is passed in from ProcessMovementKey after converting with Chr().
    &apos;-----------
    Dim bMatched, oSearchDesc, oFoundRange, bIsBackwards, oStartRange
    bMatched = True
    bIsBackwards = (searchType = &quot;F&quot; Or searchType = &quot;T&quot;)

    If Not bIsBackwards Then
        &apos; VISUAL mode will goRight AFTER the selection
        If MODE &lt;&gt; &quot;VISUAL&quot; Then
            &apos; Start searching from next character
            oTextCursor.goRight(1, bExpand)
        End If

        oStartRange = oTextCursor.getEnd()
        &apos; Go back one
        oTextCursor.goLeft(1, bExpand)
    Else
        oStartRange = oTextCursor.getStart()
    End If

    oSearchDesc = thisComponent.createSearchDescriptor()
    oSearchDesc.setSearchString(keyChar)
    oSearchDesc.SearchCaseSensitive = True
    oSearchDesc.SearchBackwards = bIsBackwards

    oFoundRange = thisComponent.findNext(oStartRange, oSearchDesc)

    If Not IsNull(oFoundRange) Then
        Dim oText, foundPos, curPos, bSearching
        oText = oTextCursor.getText()
        foundPos = oFoundRange.getStart()

        &apos; Unfortunately, we must go go to this &quot;found&quot; position one character at
        &apos; a time because I have yet to find a way to consistently move the
        &apos; Start range of the text cursor and leave the End range intact.
        If bIsBackwards Then
            curPos = oTextCursor.getEnd()
        Else
            curPos = oTextCursor.getStart()
        End If
        Do Until oText.compareRegionStarts(foundPos, curPos) = 0
            If bIsBackwards Then
                bSearching = oTextCursor.goLeft(1, bExpand)
                curPos = oTextCursor.getStart()
            Else
                bSearching = oTextCursor.goRight(1, bExpand)
                curPos = oTextCursor.getEnd()
            End If

            &apos; Prevent infinite if unable to find, but shouldn&apos;t ever happen (?)
            If Not bSearching Then
                bMatched = False
                Exit Do
            End If
        Loop

        If searchType = &quot;t&quot; Then
            oTextCursor.goLeft(1, bExpand)
        ElseIf searchType = &quot;T&quot; Then
            oTextCursor.goRight(1, bExpand)
        End If

    Else
        bMatched = False
    End If

    &apos; If matched, then we want to select PAST the character
    &apos; Else, this will counteract some weirdness. hack either way
    If Not bIsBackwards And MODE = &quot;VISUAL&quot; Then
        oTextCursor.goRight(1, bExpand)
    End If

    ProcessSearchKey = bMatched

End Function

&apos; -----------------------
&apos; Main Movement Function
&apos; -----------------------
&apos;   Default: bExpand = False, keyModifiers = 0
&apos;   keyChar is an ASCII integer (e.g. 104 for &apos;h&apos;)
Function ProcessMovementKey(keyChar, iMultiplier, iRawMultiplier, Optional bExpand, Optional keyModifiers)
    Dim oTextCursor, bSetCursor, bMatched, i
    oTextCursor = getTextCursor()
    bMatched = True
    If IsMissing(bExpand) Then bExpand = False
    If IsMissing(keyModifiers) Then keyModifiers = 0


    &apos; Check for modified keys (Ctrl, Alt, not Shift)
    If keyModifiers &gt; 1 Then
        Dim bIsControl
        bIsControl = (keyModifiers = 2) Or (keyModifiers = 8)

        &apos; Ctrl+d (100) and Ctrl+u (117)
        If bIsControl And keyChar = 100 Then &apos; 100=&apos;d&apos;
            For i = 1 To iMultiplier
                getCursor().ScreenDown(bExpand)
            Next i
        ElseIf bIsControl And keyChar = 117 Then &apos; 117=&apos;u&apos;
            For i = 1 To iMultiplier
                getCursor().ScreenUp(bExpand)
            Next i
        Else
            bMatched = False
        End If
        ProcessMovementKey = bMatched
        Exit Function
    End If

    &apos; Set global cursor to oTextCursor&apos;s new position if moved
    bSetCursor = True


    &apos; ------------------
    &apos; Movement matching
    &apos; ------------------

    &apos; ---------------------------------
    &apos; Special Case: Modified movements (f/t/F/T/i/a + target key)
    If getMovementModifier() &lt;&gt; &quot;&quot; Then
        Select Case getMovementModifier()
                &apos; f,F,t,T searching — convert int keyChar to string for search
            Case &quot;f&quot;, &quot;t&quot;, &quot;F&quot;, &quot;T&quot; :
                bMatched = False
                For i = 1 To iMultiplier
                    If ProcessSearchKey(oTextCursor, getMovementModifier(), Chr(keyChar), bExpand) Then
                        bMatched = True
                    Else
                        Exit For
                    End If
                Next i
            Case &quot;a&quot;, &quot;i&quot; :
                bMatched = GetSymbol(Chr(keyChar), getMovementModifier())
                bSetCursor = False
            Case Else :
                bSetCursor = False
                bMatched = False
        End Select

        If Not bMatched Then
            bSetCursor = False
        End If
        &apos; ---------------------------------

    Else
        Select Case keyChar
            Case 108 &apos; l
                For i = 1 To iMultiplier : oTextCursor.goRight(1, bExpand) : Next i

            Case 104 &apos; h
                For i = 1 To iMultiplier : oTextCursor.goLeft(1, bExpand) : Next i

            Case 107 &apos; k
                If MODE = &quot;VISUAL_LINE&quot; Then
                    For i = 1 To iMultiplier
                        Dim lastSelected
                        If getCursor().getPosition().Y() &lt;= VISUAL_BASE.Y() Then
                            lastSelected = getCursor().getPosition().Y()
                            If VISUAL_BASE.Y() = getCursor().getPosition().Y() Then
                                getCursor().gotoEndOfLine(False)
                                If getCursor().getPosition().Y() = VISUAL_BASE.Y() Then
                                    getCursor().goRight(1, False)
                                End If
                            End If
                            Do Until getCursor().getPosition().Y() &lt; lastSelected
                                If Not getCursor().goUp(1, bExpand) Then Exit Do
                            Loop
                            getCursor().gotoStartOfLine(bExpand)
                        ElseIf getCursor().getPosition().Y() &gt; VISUAL_BASE.Y() Then
                            getCursor().goUp(1, bExpand)
                            lastSelected = getCursor().getPosition().Y()
                            getCursor().goUp(1, bExpand)
                            If getCursor().getPosition().Y() = VISUAL_BASE.Y() Then
                                formatVisualBase()
                            Else
                                getCursor().gotoEndOfLine(bExpand)
                                If getCursor().getPosition().Y() &lt; lastSelected Then
                                    getCursor().goRight(1, bExpand)
                                End If
                            End If
                        End If
                    Next i
                    bSetCursor = False
                Else
                    For i = 1 To iMultiplier : getCursor().goUp(1, bExpand) : Next i
                    bSetCursor = False
                End If

            Case 106 &apos; j
                If MODE = &quot;VISUAL_LINE&quot; Then
                    For i = 1 To iMultiplier
                        If getCursor().getPosition().Y() &gt;= VISUAL_BASE.Y() Then
                            If VISUAL_BASE.Y() = getCursor().getPosition().Y() Then
                                getCursor().gotoStartOfLine(False)
                                getCursor().gotoEndOfLine(bExpand)
                                If getCursor().getPosition().Y() = VISUAL_BASE.Y() Then
                                    getCursor().goRight(1, bExpand)
                                End If
                            End If
                            If getCursor().goDown(1, bExpand) Then
                                getCursor().gotoStartOfLine(bExpand)
                            Else
                                getCursor().gotoEndOfLine(bExpand)
                            End If
                        ElseIf getCursor().getPosition().Y() &lt; VISUAL_BASE.Y() Then
                            getCursor().goDown(1, bExpand)
                            getCursor().gotoStartOfLine(bExpand)
                        End If
                    Next i
                    bSetCursor = False
                Else
                    For i = 1 To iMultiplier : getCursor().goDown(1, bExpand) : Next i
                    bSetCursor = False
                End If

            Case 48 &apos; 0
                getCursor().gotoStartOfLine(bExpand)
                bSetCursor = False

            Case 94 &apos; ^
                &apos; --- Move cursor to the first non‑whitespace character on the current line ---
                Dim originalLineY
                originalLineY = getCursor().getPosition().Y()

                &apos; Temporarily select the entire line to extract its text.
                getCursor().gotoEndOfLine(False)
                If getCursor().getPosition().Y() &gt; originalLineY Then
                    &apos; If we landed on the next line (line was exactly one character long), move back.
                    getCursor().goLeft(1, False)
                End If
                getCursor().gotoStartOfLine(True)
                Dim lineText As String
                lineText = getCursor().String

                &apos; Restore the original cursor (and any existing selection) before moving.
                getCursor().gotoRange(oTextCursor, False)
                getCursor().gotoStartOfLine(bExpand) &apos; Start from column 0

                &apos; Find the index (1‑based) of the first character that is not a space or tab.
                Dim firstNonBlankPos As Integer
                firstNonBlankPos = 1
                Do While firstNonBlankPos &lt;= Len(lineText)
                    Dim ch As String
                    ch = Mid(lineText, firstNonBlankPos, 1)
                    If ch &lt;&gt; &quot; &quot; And ch &lt;&gt; Chr(9) Then &apos; space or tab
                        Exit Do
                    End If
                    firstNonBlankPos = firstNonBlankPos + 1
                Loop

                &apos; If the line is empty or all whitespace, stay at column 0.
                If firstNonBlankPos &gt; Len(lineText) Then
                    firstNonBlankPos = 1
                End If

                &apos; Move right to the first non‑blank character.
                getCursor().goRight(firstNonBlankPos - 1, bExpand)

                bSetCursor = False &apos; We already moved the view cursor directly

            Case 36 &apos; $
                Dim oldPos, newPos
                oldPos = getCursor().getPosition()
                getCursor().gotoEndOfLine(bExpand)
                newPos = getCursor().getPosition()

                &apos; If the result is at the start of the line, then it must have
                &apos; jumped down a line; goLeft to return to the previous line.
                &apos;   Except for: Empty lines (check for oldPos = newPos)
                If getCursor().isAtStartOfLine() And oldPos.Y() &lt;&gt; newPos.Y() Then
                    getCursor().goLeft(1, bExpand)
                End If

                bSetCursor = False

            Case 119, 87 &apos; w, W
                For i = 1 To iMultiplier : oTextCursor.gotoNextWord(bExpand) : Next i

            Case 98, 66 &apos; b, B
                For i = 1 To iMultiplier
                    If Not MoveWordBackward(oTextCursor, bExpand) Then
                        Exit For
                    End If
                Next i
                bSetCursor = True

            Case 103 &apos; g
                If iRawMultiplier &gt; 0 Then
                    Dim targetPage As Integer
                    Dim itotalPages As Integer
                    targetPage = iMultiplier
                    itotalPages = getPageCount()
                    If targetPage &gt; itotalPages Then targetPage = itotalPages
                    getCursor().jumpToPage(targetPage, bExpand)
                    oTextCursor.gotoRange(getCursor().getStart(), bExpand)
                ElseIf getSpecial() = &quot;g&quot; Then
                    &apos; Handle gg with visual modes
                    If MODE = &quot;VISUAL&quot; Then
                        Dim oldPosG
                        oldPosG = getCursor().getPosition()
                        getCursor().gotoRange(getCursor().getStart(), True)
                        If Not samePos(getCursor().getPosition(), oldPosG) Then
                            getCursor().gotoRange(getCursor().getEnd(), False)
                        End If
                    ElseIf MODE = &quot;VISUAL_LINE&quot; Then
                        Do Until getCursor().getPosition().Y() &lt;= VISUAL_BASE.Y()
                            getCursor().goUp(1, False)
                        Loop
                        If getCursor().getPosition().Y() = VISUAL_BASE.Y() Then
                            formatVisualBase()
                        End If
                    End If
                    Dim bExpandLocal
                    bExpandLocal = (MODE = &quot;VISUAL&quot; Or MODE = &quot;VISUAL_LINE&quot;)
                    getCursor().gotoStart(bExpandLocal)
                    bSetCursor = False
                    resetSpecial(True)
                Else
                    &apos; Set special &apos;g&apos; and wait for the next key
                    setSpecial(&quot;g&quot;)
                    bMatched = True
                    bSetCursor = False
                End If

            Case 71 &apos; G
                oTextCursor.gotoEnd(bExpand)

            Case 101 &apos; e
                For i = 1 To iMultiplier
                    oTextCursor.goRight(1, bExpand)
                    oTextCursor.gotoEndOfWord(bExpand)
                Next i

            Case 41 &apos; )
                For i = 1 To iMultiplier : oTextCursor.gotoNextSentence(bExpand) : Next i

            Case 40 &apos; (
                For i = 1 To iMultiplier : oTextCursor.gotoPreviousSentence(bExpand) : Next i

            Case 125 &apos; }
                For i = 1 To iMultiplier : oTextCursor.gotoNextParagraph(bExpand) : Next i

            Case 123 &apos; {
                For i = 1 To iMultiplier : oTextCursor.gotoPreviousParagraph(bExpand) : Next i

            Case Else
                bSetCursor = False
                bMatched = False
        End Select
    End If

    &apos; If oTextCursor was moved, set global cursor to its position
    If bSetCursor Then
        getCursor().gotoRange(oTextCursor.getStart(), False)
    End If

    &apos; If oTextCursor was moved and is in VISUAL mode, update selection
    If bSetCursor And bExpand Then
        thisComponent.getCurrentController.Select(oTextCursor)
    End If

    ProcessMovementKey = bMatched
End Function

Function GetSymbol(symbol As String, modifier As String) As Boolean
    Dim endSymbol As String
    Select Case symbol
        Case &quot;(&quot;, &quot;)&quot;
            symbol = &quot;(&quot; : endSymbol = &quot;)&quot;
        Case &quot;{&quot;, &quot;}&quot;
            symbol = &quot;{&quot; : endSymbol = &quot;}&quot;
        Case &quot;[&quot;, &quot;]&quot;
            symbol = &quot;[&quot; : endSymbol = &quot;]&quot;
        Case &quot;&lt;&quot;, &quot;&gt;&quot;
            symbol = &quot;&lt;&quot; : endSymbol = &quot;&gt;&quot;
        Case &quot;.&quot;
            symbol = &quot;.&quot; : endSymbol = &quot;.&quot;
        Case &quot;,&quot;
            symbol = &quot;,&quot; : endSymbol = &quot;,&quot;
        Case &quot;&apos;&quot; :
            symbol = &quot;‘&quot; : endSymbol = &quot;’&quot;
            GetSymbol = FindMatchingPair(symbol, endSymbol, modifier)
            If GetSymbol = &quot;&quot; Then
                GetSymbol = FindMatchingPair(&quot;&apos;&quot;, &quot;&apos;&quot;, modifier)
                Exit Function
            End If
        Case Chr(34) :
            symbol = &quot;“&quot; : endSymbol = &quot;”&quot;
            GetSymbol = FindMatchingPair(symbol, endSymbol, modifier)
            If GetSymbol = &quot;&quot; Then
                GetSymbol = FindMatchingPair(Chr(34), Chr(34), modifier)
                Exit Function
            End If
        Case Else
            GetSymbol = False
            Exit Function
    End Select
    GetSymbol = FindMatchingPair(symbol, endSymbol, modifier)
End Function

Function FindMatchingPair(startChar As String, endChar As String, modifier As String) As Boolean
    Dim oDoc As Object
    Dim oCursor As Object
    Dim oTempCursor As Object
    Dim i As Integer, j As Integer
    Dim foundForward As Boolean
    Dim forwardPos As Object

    oDoc = ThisComponent

    &apos; Search forward for endChar from current view cursor position
    Set oCursor = oDoc.Text.createTextCursorByRange(getCursor().getStart())
    foundForward = False
    For i = 1 To 1000
        If Not oCursor.goRight(1, False) Then Exit For
        Set oTempCursor = oDoc.Text.createTextCursorByRange(oCursor.getStart())
        oTempCursor.goRight(1, True)
        If oTempCursor.getString() = endChar Then
            foundForward = True
            Set forwardPos = oTempCursor.getStart()
            Exit For
        End If
    Next i

    If Not foundForward Then
        FindMatchingPair = False
        Exit Function
    End If

    &apos; Search backward from forwardPos for startChar
    Set oCursor = oDoc.Text.createTextCursorByRange(forwardPos)
    For j = 1 To 2000
        If Not oCursor.goLeft(1, False) Then Exit For
        Set oTempCursor = oDoc.Text.createTextCursorByRange(oCursor.getStart())
        oTempCursor.goLeft(1, True)
        If oTempCursor.getString() = startChar Then
            Dim startPos As Object
            Dim endPos As Object
            Dim oEndCursor As Object

            If modifier = &quot;a&quot; Then
                Set startPos = oTempCursor.getStart()
                Set oEndCursor = oDoc.Text.createTextCursorByRange(forwardPos)
                oEndCursor.goRight(1, False)
                Set endPos = oEndCursor.getStart()
            Else &apos; &quot;i&quot;
                oTempCursor.goRight(1, True)
                Set startPos = oTempCursor.getStart()
                Set endPos = forwardPos
            End If

            &apos; Move the VIEW cursor to startPos, then select to endPos
            &apos; getTextCursor() derives from getCursor(), so this is what yankSelection needs
            getCursor().gotoRange(startPos, False)
            getCursor().gotoRange(endPos, True)

            FindMatchingPair = True
            Exit Function
        End If
    Next j

    FindMatchingPair = False
End Function
Sub initVibreoffice
    Dim oTextCursor
    &apos; Initializing
    VIBREOFFICE_STARTED = True
    VIEW_CURSOR = thisComponent.getCurrentController.getViewCursor

    resetMultiplier()
    gotoMode(&quot;NORMAL&quot;)

    &apos; Show terminal cursor
    oTextCursor = getTextCursor()

    If oTextCursor Is Nothing Then
        &apos; Do nothing
    Else
        cursorReset(oTextCursor)
    End If

    sStartXKeyHandler()

    &apos; selection change listener to track page changes
    LAST_PAGE = getPageNum()
    oSelectionListener = CreateUnoListener(&quot;SelectionChange_&quot;, &quot;com.sun.star.view.XSelectionChangeListener&quot;)
    ThisComponent.CurrentController.addSelectionChangeListener(oSelectionListener)

End Sub

Sub Main
    If Not VIBREOFFICE_STARTED Then
        initVibreoffice()
    End If

    &apos; Toggle enable/disable
    VIBREOFFICE_ENABLED = Not VIBREOFFICE_ENABLED

    &apos; Restore statusbar
    If Not VIBREOFFICE_ENABLED Then restoreStatus()
End Sub
</script:module>